---
layout: documentation
title: Hello Roles
parent: Basics
ancestor: Documentation
url: basics/hello_roles
---

# Hello Roles

The syntax of Choral is heavily inspired by one of the most widely-used mainstream languages: Java. Thus, Java developers (and akin, like C++/#) benefit from a graceful learning curve to grasp the main concepts of the Choral language. 

More so, one of the main aims of Choral is to produce software libraries whose APIs look like "idiomatic" Java APIs. To do that, it incorporates a substantial set of features that would be commonly considered necessary to use and produce Java APIs: classes, interfaces, generics, inheritance, and method overloading. 

APIs generated by Choral support lambda expressions, in the sense that Java programmers can pass lambda expressions as arguments to our APIs. 

All values in Choral are distributed over one or more roles, using the `@`-notation, e.g., `String@Role x` declares a `String` (as in Java) but located at some endpoint, abstracted by `Role`. Roles are part of data types in Choral, adding a new dimension to typing.
With roles, Choral can express that an object is implemented "choreographically", i.e., that

- its state (represented by its fields) is distributed among a set of roles;
- and its methods include behaviour specific to each of its roles.

Choral objects have types of the form `T@(R1, ..., Rn)`, where `T` is the usual interface of the object, and `R1, ... , Rn` are the roles that collaboratively implement the object.

<div class="border border-info bg-light px-5">
Mind not to confuse the roles `@`-notation with the similar syntax of Java annotations. Java annotations are supported by Choral, but appear at distinct syntactic nodes (e.g., before symbol declarations) with respect to roles, which only appear in data types, e.g., in `String@Role`, after the `String` interface, we find the role notation `@` and the role `Role`.
</div>

The degenerate case of values involving one role (as in `String@Role`) allows Choral to reuse existing Java classes and interfaces, lifted mechanically to Choral types and made available to Choral code. For example, the literal `"Hello from A"@A` is a string value `"Hello from A"` located at role `A`. Code involving different roles can be freely mixed in Choral, as in the following snippet.

```choral
class HelloRoles@( A, B ) {
   public static void sayHello() {
      String@A a = "Hello from A"@A; 
      String@B b = "Hello from B"@B; 
      System@A.out.println( a ); 
      System@B.out.println( b ); 
   }
}
```

The code above defines a class, `HelloRoles`, parameterised over two roles, `A` and `B`.
The example is useful to show that the single-role notation seen before e.g., `String@Role` is syntactic sugar for `String@( A )` where the full `@( ... )` notation surrounds the declaration of the (singleton) list of roles of that data type.

In the `HelloRoles` class, method `sayHello` defines a variable `a` of type "String at A" (`String@A`) to which we assign the value `"Hello from A"` located at `A` (`"Hello from A"@A`).
Similarly, we define and assign a value to a variable `b` as a string located at `B`.

In the last two lines of the method, we print variable `a` by using the `System` object at `A` (`System@A`), and then we print variable `b` at role `B`.

Roles are part of data types in Choral, adding a new dimension to typing. For example, the statementString@A a = "Hello from B"@Bwouldbeill-typed,becausetheexpressiononthe right returns data at a different role from that expected by the left-hand side.

## From Choral to Java. 

Given the class `HelloRoles`, the Choral compiler generates for each role a Java class with the behaviour for that role, in compliance with the source Choral class.

Assuming we saved the Choral program above in a file called `HelloWorlds.ch`, we can launch the Choral compiler with the command <kbd>java -jar choral.jar HelloWorlds.ch</kbd>.

We will obtain two Java classes: the Java class for role `A` is `HelloRoles_A` and the class for `B` is `HelloRoles_B`.

<div class="row">
<div class="col-lg-6 col-12">
```java
class HelloRoles_A {
	public static void sayHello() {
		String a = "Hello from A";
		System.out.println( a );
   }
}
```
</div>
<div class="col-lg-6 col-12">
```java
class HelloRoles_B {
	public static void sayHello() {
		String b = "Hello from B";
		System.out.println( b );  
   }
}
``` 
</div>
</div>

Each generated class contains only the instructions that pertain that role. 

If Java developers want to implement the behaviour of method `sayHello` for a specific role of the `HelloRoles` choreography, say `A`, they just need to invoke the generated `sayHello` method in the respective generated class (`HelloRoles_A`). 

If all Java programs interested in participating to `HelloRoles` do that, then their resulting global behaviour complies by construction with the source Choral program.